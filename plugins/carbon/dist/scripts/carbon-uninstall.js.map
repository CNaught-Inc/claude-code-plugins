{
  "version": 3,
  "sources": ["../../src/scripts/carbon-uninstall.ts", "../../src/data-store.ts"],
  "sourcesContent": ["/**\n * Carbon Uninstall Script\n *\n * Removes carbon tracking data for the current project:\n * 1. Deletes sessions matching the current project path from the database\n * 2. If no sessions remain, deletes the database (~/.claude/carbon-tracker.db)\n *\n * Statusline and settings cleanup is handled by the uninstall command (uninstall.md).\n *\n * Usage:\n *   carbon-uninstall.js --project-path /path/to/project\n */\n\nimport * as fs from 'fs';\n\nimport { getDatabasePath, openDatabase } from '../data-store.js';\n\nfunction deleteProjectSessions(projectPath: string): { deleted: number; remaining: number } {\n    const dbPath = getDatabasePath();\n    if (!fs.existsSync(dbPath)) {\n        return { deleted: 0, remaining: 0 };\n    }\n\n    const db = openDatabase();\n    try {\n        // Project paths may be stored encoded (slashes become dashes) or as-is\n        const encodedPath = projectPath.replace(/\\//g, '-');\n\n        const deleteResult = db.prepare(\n            'DELETE FROM sessions WHERE project_path = ? OR project_path = ?'\n        ).run(encodedPath, projectPath);\n        const deleted = deleteResult.changes;\n\n        const countRow = db.prepare('SELECT COUNT(*) as count FROM sessions').get() as { count: number };\n        return { deleted, remaining: countRow.count };\n    } finally {\n        db.close();\n    }\n}\n\nfunction deleteDatabase(): void {\n    const dbPath = getDatabasePath();\n\n    if (fs.existsSync(dbPath)) {\n        fs.unlinkSync(dbPath);\n        console.log(`  Deleted database: ${dbPath}`);\n    } else {\n        console.log('  Database not found (already removed)');\n    }\n    for (const suffix of ['-wal', '-shm']) {\n        const walPath = dbPath + suffix;\n        if (fs.existsSync(walPath)) {\n            fs.unlinkSync(walPath);\n        }\n    }\n}\n\nfunction main(): void {\n    const args = process.argv.slice(2);\n    const pathIndex = args.indexOf('--project-path');\n    const projectPath = pathIndex !== -1 ? args[pathIndex + 1] : null;\n\n    console.log('\\n');\n    console.log('========================================');\n    console.log('  CNaught Carbon Tracker Uninstall      ');\n    console.log('========================================');\n    console.log('\\n');\n\n    if (!projectPath) {\n        console.log('  Error: --project-path is required');\n        process.exit(1);\n    }\n\n    console.log(`  Removing sessions for: ${projectPath}\\n`);\n    const { deleted, remaining } = deleteProjectSessions(projectPath);\n    console.log(`  Deleted ${deleted} session(s) for this project`);\n\n    if (remaining === 0) {\n        console.log('  No sessions remain \u2014 deleting database...\\n');\n        deleteDatabase();\n    } else {\n        console.log(`  ${remaining} session(s) from other projects remain`);\n        console.log('  Database left intact');\n    }\n\n    console.log('\\n');\n    console.log('========================================');\n    console.log('\\n');\n}\n\nmain();\n", "/**\n * Data Store\n *\n * SQLite-based local storage for session carbon data.\n * Database location: ~/.claude/carbon-tracker.db\n */\n\nimport { Database } from 'bun:sqlite';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Session record in the database\n */\nexport interface SessionRecord {\n    sessionId: string;\n    projectPath: string;\n    inputTokens: number;\n    outputTokens: number;\n    cacheCreationTokens: number;\n    cacheReadTokens: number;\n    totalTokens: number;\n    energyWh: number;\n    co2Grams: number;\n    primaryModel: string;\n    createdAt: Date;\n    updatedAt: Date;\n}\n\n/**\n * Aggregate statistics\n */\nexport interface AggregateStats {\n    totalSessions: number;\n    totalTokens: number;\n    totalInputTokens: number;\n    totalOutputTokens: number;\n    totalCacheCreationTokens: number;\n    totalCacheReadTokens: number;\n    totalEnergyWh: number;\n    totalCO2Grams: number;\n}\n\n/**\n * Daily stats for reporting\n */\nexport interface DailyStats {\n    date: string;\n    sessions: number;\n    tokens: number;\n    energyWh: number;\n    co2Grams: number;\n}\n\n/**\n * Project stats for reporting\n */\nexport interface ProjectStats {\n    projectPath: string;\n    sessions: number;\n    tokens: number;\n    energyWh: number;\n    co2Grams: number;\n}\n\n/**\n * Get the database file path\n */\nexport function getDatabasePath(): string {\n    const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n    return path.join(homeDir, '.claude', 'carbon-tracker.db');\n}\n\n/**\n * Ensure the database directory exists\n */\nfunction ensureDbDirectory(): void {\n    const dbPath = getDatabasePath();\n    const dbDir = path.dirname(dbPath);\n\n    if (!fs.existsSync(dbDir)) {\n        fs.mkdirSync(dbDir, { recursive: true });\n    }\n}\n\n/**\n * Open database connection\n */\nexport function openDatabase(): Database {\n    ensureDbDirectory();\n    const dbPath = getDatabasePath();\n    return new Database(dbPath);\n}\n\n/**\n * Initialize the database schema\n */\nexport function initializeDatabase(db: Database): void {\n    // Migration: clean up auth_config table and synced_at index from older versions\n    db.exec('DROP TABLE IF EXISTS auth_config');\n    db.exec('DROP INDEX IF EXISTS idx_sessions_synced_at');\n\n    db.exec(`\n        CREATE TABLE IF NOT EXISTS sessions (\n            session_id TEXT PRIMARY KEY,\n            project_path TEXT NOT NULL,\n            input_tokens INTEGER NOT NULL DEFAULT 0,\n            output_tokens INTEGER NOT NULL DEFAULT 0,\n            cache_creation_tokens INTEGER NOT NULL DEFAULT 0,\n            cache_read_tokens INTEGER NOT NULL DEFAULT 0,\n            total_tokens INTEGER NOT NULL DEFAULT 0,\n            energy_wh REAL NOT NULL DEFAULT 0,\n            co2_grams REAL NOT NULL DEFAULT 0,\n            primary_model TEXT NOT NULL DEFAULT 'unknown',\n            created_at TEXT NOT NULL,\n            updated_at TEXT NOT NULL\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions(created_at);\n        CREATE INDEX IF NOT EXISTS idx_sessions_project_path ON sessions(project_path);\n\n        CREATE TABLE IF NOT EXISTS plugin_config (\n            key TEXT PRIMARY KEY,\n            value TEXT NOT NULL\n        );\n    `);\n}\n\n/**\n * Upsert a session record\n * Preserves created_at on update\n */\nexport function upsertSession(\n    db: Database,\n    session: SessionRecord\n): void {\n    const stmt = db.prepare(`\n        INSERT INTO sessions (\n            session_id, project_path, input_tokens, output_tokens,\n            cache_creation_tokens, cache_read_tokens, total_tokens,\n            energy_wh, co2_grams, primary_model, created_at, updated_at\n        ) VALUES (\n            $sessionId, $projectPath, $inputTokens, $outputTokens,\n            $cacheCreationTokens, $cacheReadTokens, $totalTokens,\n            $energyWh, $co2Grams, $primaryModel, $createdAt, $updatedAt\n        )\n        ON CONFLICT(session_id) DO UPDATE SET\n            project_path = excluded.project_path,\n            input_tokens = excluded.input_tokens,\n            output_tokens = excluded.output_tokens,\n            cache_creation_tokens = excluded.cache_creation_tokens,\n            cache_read_tokens = excluded.cache_read_tokens,\n            total_tokens = excluded.total_tokens,\n            energy_wh = excluded.energy_wh,\n            co2_grams = excluded.co2_grams,\n            primary_model = excluded.primary_model,\n            updated_at = excluded.updated_at\n    `);\n\n    stmt.run({\n        $sessionId: session.sessionId,\n        $projectPath: session.projectPath,\n        $inputTokens: session.inputTokens,\n        $outputTokens: session.outputTokens,\n        $cacheCreationTokens: session.cacheCreationTokens,\n        $cacheReadTokens: session.cacheReadTokens,\n        $totalTokens: session.totalTokens,\n        $energyWh: session.energyWh,\n        $co2Grams: session.co2Grams,\n        $primaryModel: session.primaryModel,\n        $createdAt: session.createdAt.toISOString(),\n        $updatedAt: session.updatedAt.toISOString()\n    });\n}\n\n/**\n * Get a session by ID\n */\nexport function getSession(db: Database, sessionId: string): SessionRecord | null {\n    const stmt = db.prepare('SELECT * FROM sessions WHERE session_id = ?');\n    const row = stmt.get(sessionId) as Record<string, unknown> | undefined;\n\n    if (!row) {\n        return null;\n    }\n\n    return rowToSession(row);\n}\n\n/**\n * Get all session IDs in the database\n */\nexport function getAllSessionIds(db: Database): string[] {\n    const stmt = db.prepare('SELECT session_id FROM sessions');\n    const rows = stmt.all() as { session_id: string }[];\n    return rows.map((r) => r.session_id);\n}\n\n/**\n * Check if a session exists\n */\nexport function sessionExists(db: Database, sessionId: string): boolean {\n    const stmt = db.prepare('SELECT 1 FROM sessions WHERE session_id = ?');\n    return stmt.get(sessionId) !== undefined;\n}\n\n/**\n * Get aggregate statistics\n */\nexport function getAggregateStats(db: Database): AggregateStats {\n    const stmt = db.prepare(`\n        SELECT\n            COUNT(*) as total_sessions,\n            COALESCE(SUM(total_tokens), 0) as total_tokens,\n            COALESCE(SUM(input_tokens), 0) as total_input_tokens,\n            COALESCE(SUM(output_tokens), 0) as total_output_tokens,\n            COALESCE(SUM(cache_creation_tokens), 0) as total_cache_creation_tokens,\n            COALESCE(SUM(cache_read_tokens), 0) as total_cache_read_tokens,\n            COALESCE(SUM(energy_wh), 0) as total_energy_wh,\n            COALESCE(SUM(co2_grams), 0) as total_co2_grams\n        FROM sessions\n    `);\n\n    const row = stmt.get() as Record<string, unknown>;\n\n    return {\n        totalSessions: Number(row.total_sessions),\n        totalTokens: Number(row.total_tokens),\n        totalInputTokens: Number(row.total_input_tokens),\n        totalOutputTokens: Number(row.total_output_tokens),\n        totalCacheCreationTokens: Number(row.total_cache_creation_tokens),\n        totalCacheReadTokens: Number(row.total_cache_read_tokens),\n        totalEnergyWh: Number(row.total_energy_wh),\n        totalCO2Grams: Number(row.total_co2_grams)\n    };\n}\n\n/**\n * Get daily statistics for the last N days\n */\nexport function getDailyStats(db: Database, days: number = 7): DailyStats[] {\n    const stmt = db.prepare(`\n        SELECT\n            DATE(created_at) as date,\n            COUNT(*) as sessions,\n            SUM(total_tokens) as tokens,\n            SUM(energy_wh) as energy_wh,\n            SUM(co2_grams) as co2_grams\n        FROM sessions\n        WHERE created_at >= DATE('now', '-' || ? || ' days')\n        GROUP BY DATE(created_at)\n        ORDER BY date\n    `);\n\n    const rows = stmt.all(days) as Record<string, unknown>[];\n\n    return rows.map((row) => ({\n        date: row.date as string,\n        sessions: Number(row.sessions),\n        tokens: Number(row.tokens),\n        energyWh: Number(row.energy_wh),\n        co2Grams: Number(row.co2_grams)\n    }));\n}\n\n/**\n * Get project statistics for the last N days\n */\nexport function getProjectStats(db: Database, days: number = 7): ProjectStats[] {\n    const stmt = db.prepare(`\n        SELECT\n            project_path,\n            COUNT(*) as sessions,\n            SUM(total_tokens) as tokens,\n            SUM(energy_wh) as energy_wh,\n            SUM(co2_grams) as co2_grams\n        FROM sessions\n        WHERE created_at >= DATE('now', '-' || ? || ' days')\n        GROUP BY project_path\n        ORDER BY co2_grams DESC\n    `);\n\n    const rows = stmt.all(days) as Record<string, unknown>[];\n\n    return rows.map((row) => ({\n        projectPath: row.project_path as string,\n        sessions: Number(row.sessions),\n        tokens: Number(row.tokens),\n        energyWh: Number(row.energy_wh),\n        co2Grams: Number(row.co2_grams)\n    }));\n}\n\n/**\n * Get the plugin installed-at timestamp\n */\nexport function getInstalledAt(db: Database): Date | null {\n    const stmt = db.prepare(\"SELECT value FROM plugin_config WHERE key = 'installed_at'\");\n    const row = stmt.get() as { value: string } | undefined;\n    return row ? new Date(row.value) : null;\n}\n\n/**\n * Set the plugin installed-at timestamp (only if not already set)\n */\nexport function setInstalledAt(db: Database): void {\n    const stmt = db.prepare(\n        \"INSERT OR IGNORE INTO plugin_config (key, value) VALUES ('installed_at', ?)\"\n    );\n    stmt.run(new Date().toISOString());\n}\n\n/**\n * Convert a database row to a SessionRecord\n */\nfunction rowToSession(row: Record<string, unknown>): SessionRecord {\n    return {\n        sessionId: row.session_id as string,\n        projectPath: row.project_path as string,\n        inputTokens: Number(row.input_tokens),\n        outputTokens: Number(row.output_tokens),\n        cacheCreationTokens: Number(row.cache_creation_tokens),\n        cacheReadTokens: Number(row.cache_read_tokens),\n        totalTokens: Number(row.total_tokens),\n        energyWh: Number(row.energy_wh),\n        co2Grams: Number(row.co2_grams),\n        primaryModel: row.primary_model as string,\n        createdAt: new Date(row.created_at as string),\n        updatedAt: new Date(row.updated_at as string)\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAaA,IAAAA,MAAoB;;;ACNpB,wBAAyB;AACzB,SAAoB;AACpB,WAAsB;AA2Df,SAAS,kBAA0B;AACtC,QAAM,UAAU,QAAQ,IAAI,QAAQ,QAAQ,IAAI,eAAe;AAC/D,SAAY,UAAK,SAAS,WAAW,mBAAmB;AAC5D;AAKA,SAAS,oBAA0B;AAC/B,QAAM,SAAS,gBAAgB;AAC/B,QAAM,QAAa,aAAQ,MAAM;AAEjC,MAAI,CAAI,cAAW,KAAK,GAAG;AACvB,IAAG,aAAU,OAAO,EAAE,WAAW,KAAK,CAAC;AAAA,EAC3C;AACJ;AAKO,SAAS,eAAyB;AACrC,oBAAkB;AAClB,QAAM,SAAS,gBAAgB;AAC/B,SAAO,IAAI,2BAAS,MAAM;AAC9B;;;AD3EA,SAAS,sBAAsB,aAA6D;AACxF,QAAM,SAAS,gBAAgB;AAC/B,MAAI,CAAI,eAAW,MAAM,GAAG;AACxB,WAAO,EAAE,SAAS,GAAG,WAAW,EAAE;AAAA,EACtC;AAEA,QAAM,KAAK,aAAa;AACxB,MAAI;AAEA,UAAM,cAAc,YAAY,QAAQ,OAAO,GAAG;AAElD,UAAM,eAAe,GAAG;AAAA,MACpB;AAAA,IACJ,EAAE,IAAI,aAAa,WAAW;AAC9B,UAAM,UAAU,aAAa;AAE7B,UAAM,WAAW,GAAG,QAAQ,wCAAwC,EAAE,IAAI;AAC1E,WAAO,EAAE,SAAS,WAAW,SAAS,MAAM;AAAA,EAChD,UAAE;AACE,OAAG,MAAM;AAAA,EACb;AACJ;AAEA,SAAS,iBAAuB;AAC5B,QAAM,SAAS,gBAAgB;AAE/B,MAAO,eAAW,MAAM,GAAG;AACvB,IAAG,eAAW,MAAM;AACpB,YAAQ,IAAI,uBAAuB,MAAM,EAAE;AAAA,EAC/C,OAAO;AACH,YAAQ,IAAI,wCAAwC;AAAA,EACxD;AACA,aAAW,UAAU,CAAC,QAAQ,MAAM,GAAG;AACnC,UAAM,UAAU,SAAS;AACzB,QAAO,eAAW,OAAO,GAAG;AACxB,MAAG,eAAW,OAAO;AAAA,IACzB;AAAA,EACJ;AACJ;AAEA,SAAS,OAAa;AAClB,QAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AACjC,QAAM,YAAY,KAAK,QAAQ,gBAAgB;AAC/C,QAAM,cAAc,cAAc,KAAK,KAAK,YAAY,CAAC,IAAI;AAE7D,UAAQ,IAAI,IAAI;AAChB,UAAQ,IAAI,0CAA0C;AACtD,UAAQ,IAAI,0CAA0C;AACtD,UAAQ,IAAI,0CAA0C;AACtD,UAAQ,IAAI,IAAI;AAEhB,MAAI,CAAC,aAAa;AACd,YAAQ,IAAI,qCAAqC;AACjD,YAAQ,KAAK,CAAC;AAAA,EAClB;AAEA,UAAQ,IAAI,4BAA4B,WAAW;AAAA,CAAI;AACvD,QAAM,EAAE,SAAS,UAAU,IAAI,sBAAsB,WAAW;AAChE,UAAQ,IAAI,aAAa,OAAO,8BAA8B;AAE9D,MAAI,cAAc,GAAG;AACjB,YAAQ,IAAI,oDAA+C;AAC3D,mBAAe;AAAA,EACnB,OAAO;AACH,YAAQ,IAAI,KAAK,SAAS,wCAAwC;AAClE,YAAQ,IAAI,wBAAwB;AAAA,EACxC;AAEA,UAAQ,IAAI,IAAI;AAChB,UAAQ,IAAI,0CAA0C;AACtD,UAAQ,IAAI,IAAI;AACpB;AAEA,KAAK;",
  "names": ["fs"]
}
